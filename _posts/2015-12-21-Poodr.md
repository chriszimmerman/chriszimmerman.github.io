---
layout: post
title: Lessons Learned from Sandi Metz's Practical Object-Oriented Design In Ruby
comments: true
---

##Intro

At work, our reading group has been reading Practical Object-Oriented Design In Ruby. At the point of writing this blog post, we are about halfway through the book. Sandi's book has a number of valuable insights and provides interesting perspectices on OO design. I'd like to share some of what I've learned in the course of reading the book.

##Designing for changeability

Your software WILL change. This is an inevitability.

What's not inevitable is knowing what the actual changes will be. Some folks predict what changes will be required in the future and design their applications in anticipation for these future, not-yet-determined changes. However, there is no guarantee that these changes will actually have to be implemented. 

OO design isn't about predicting the future. It's about putting your application in a position where it can easily accomodate future change, regardless of what that change is.

To put it in Sandi's words: "Design is more the art of preserving changeablility than it is the act of achieving perfection."

I've never thought about design this way. I now take this into account when designing software.

##Code that's easy to change

The idea that code should be easy to change is a no-brainer. Sandi gives criteria for code that's easy to change:

	1) Changes have no unexpected side effects
	2) Small changes in requirements require correspondingly small changes in code
	3) Existing code is easy to reuse
	4) The easiest way to make a change is to add code that in itself is easy to change

These criteria resonated with me, particularly 1 and 2. I've worked in code where I had to be very diligent about investigating what side effects would be caused by code I changed, which placed a heavy mental load on my brain. I've also had experiences where business folks wanted a "small feature change" that "should only be a one line change" that ending up being significantly more effort because of the existing code.

In order for code to meet these criteria, Sandi suggests that code has the following qualities:

	Transparent - The consequences of change should be obvious in the code that is changing and in distant code relies upon it
	Reasonable - The cost of any change should be proportional to the benefitis the change achieves
	Usable - Existing code should be usable in new and unexpected contexts
	Exemplary -  The code itself should encourage those who change it to perpetuate these qualities

I believe a lot of people already think this makes sense, but it's great that Sandi has put it into words.

##Managing dependencies

Sandi devotes a chapter in her book to managing dependencies. Dependencies are needed in an application. Objects need to know about each other to some extent in order to communicate. However, knowing too much can lead to tight coupling. 

An object has a dependency when it knows:

	1) The name of another class
	2) The name of method on an object other than itself
	3) The arguments that a method needs
	4) The order of those arguments

When objects are tightly coupled, they tend to act like one entity. When you use one object, you use them all. The same goes for testing. Consequently, when a change needs to be made to one object, a change usually needs to be made in the other objects. Going back to the criteria of easy to change code, a small change in requirements can result in many changes being made in the code. Tightly coupled code is also hard to be reused in multiple contexts.

There are techniques to write loosely coupled code: dependency injection, dependency isolation, and removal of argument order dependences.

write loosely coupled code to fix this -> 
	dependency injection
	isolate dependences -> isolate instance creation, isolate vulnerable external messages,
	remove argument order dependencies  -> explicitly define defaults
	choose dependency direction -> recognize concretions and abstractions, avoid dependent-laden classes, find dependencies that matter

##Thinking about applications in terms of messaging

Sandi provides a unique perspective on how objects in an application interact with one another. Instead of thinking about objects calling methods on other objects, think about it like objects sending each other <em>messages</em>.

##Conclusion


##Resources

[Practical Object-Oriented Design in Ruby: An Agile Primer](http://smile.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_sc_1?ie=UTF8&qid=1450447653&sr=8-1-spell&keywords=practical+oo+design+in+ruby)
