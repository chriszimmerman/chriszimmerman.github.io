<p>Proceses In Elixir</p>

<p>Elixir makes use to the Erlang VM to create and manage many processes. Concurrency is easy and inexpensive in Elixir.</p>

<p>You can make a new process in Elixir by using the spawn function:</p>

<pre><code>spawn(module, :function_name, [optional_arguments])
</code></pre>

<p>The spawn function takes a module and a function from said module, as well as a list of optional arguments to pass to the function. Spawn retruns a process identifier, or pid. A pid consists of three numbers which are used to identify a process. If you type <code>self</code> into iex, youâ€™ll find that iex itself runs as an elixir process.</p>

<pre><code>iex(1)&gt; self
#PID&lt;0.53.0&gt;
</code></pre>

<p>Processes need a way to communicate with each other in order to do anything meaningful. In Elixir, processes achieve this with messages. Processes send messages with data to other processes that receive those messages and handle the data accordingly. </p>

<p>Here is a simple example:</p>

<p>proctut.exs</p>

<pre><code>defmodule ProcessMessage do
	def send_message msg do
		destination_pid = spawn(ProcessMessage, :get_message, [])
		IO.puts "#{inspect(self)} here." 
		IO.puts "Sending message to #{inspect(destination_pid)}"
		send destination_pid, {self, msg}
	end	

	def get_message do
		receive do
			{sender, msg} -&gt; IO.puts "#{inspect(self)} here."
							 IO.puts "Received a message from #{inspect(sender)}." 
							 IO.puts "It says \"#{msg}\"."
		end
	end
end

ProcessMessage.send_message "Why hello there!"
</code></pre>

<p>The send_message function takes in a string which will get sent to a process it creates. The created process will run the get_message function, which just waits until it receives a message. It prints the pid of the process that sent the message as well as the message itself. It then terminates.</p>
